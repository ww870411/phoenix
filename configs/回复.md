以下是我逐条对你的答复

我想做的是“表达式求值”的后端服务：                                                                                                                                                               
不再继续扩张“二级视图”，而是读取上述两张物化视图与既有表（如常量），在 Python 侧完成表达式解析与口径（本期日/同期日/本期月/同期月/本供暖期/同供暖期）对应的值替换。                                           
目标输出：返回与“字典样例”的结构一致，但 数据 内的表达式被替换为实际值，供前端直接渲染（前端不解析公式）。                                                                                         
1.口径与映射规则：                                                                                                                                                                               
当目标列为“本期日/同期日/本期月/同期月/本供暖期/同供暖期”时，表达式中出现的“项目名”（如“售电量”）自动映射到对应窗口值（例如本期日→value_biz_date、同期日→value_peer_date、本期月→sum_month_biz、…）。                                                                                                                                                                              
diff_rate() 解释为“增长率”，计算 (biz - peer) / NULLIF(abs(peer), 0)，除零返回 None。                                                                                                            
c.<常量> 来自 constant_data，按 主键 与生效口径查询，其中对应关系为：
value_biz_date：25-26
value_peer_date：24-25
sum_month_biz：25-26
sum_month_peer：24-25
sum_ytd_biz：25-26
sum_ytd_peer：24-25

                                                                                                                 
2.主视图选择：                                                                                                                                                                                       
以 查询数据源.主表 作为主数据域：                                                                                                                                                                  
sum_basic_data：通过 company（根据设定的主键，一般为company） + （表达式中的中文项目名，根据下方的“项目字典”反向查询到英文item名） 定位。                                                                                                                                                    
                                                                                                              
                                                                                                                                                                                                           
3.拟定后端函数                                                                                                                                                                               
放置位置：backend/app/services/runtime_expression.py                                                                                                                                                   
函数签名                                                                                                                                                                                               
def render_spec(spec: dict, project_key: str, primary_key: dict, *, trace: bool = False) -> dict:                                                                                                  
4.行为要点                                                                                                                                                                                               
解析 spec['查询数据源']，识别主表、主键、常量缩写表                                                                                                                                                
预取主表数据（一次性拉取该单位/中心所需全部 item 行），构建 metrics_cache[item_cn][frame]                                                                                                       
预取常量表，构建 const_cache[name][frame]（若常量不分口径则为标量）                                                                                                                                
逐列带入“目标口径 frame”上下文，对每个单元格表达式进行安全求值（白名单运算与函数），替换为实际值                                                                                                   
trace=True 时返回 _trace（每格的展开式、依赖项、除零与空值情况）                                                                                                                                   
                                                                                                                                                                                                           
需要确认的点                                                                                                                                                                                                                                                                                                                                                                                                
1.差异列“日差异/月差异/供暖期差异”是否明确为“增长率”？如果其中某些列希望“差值”，请分别指定。
是差异率，注意0为分母的情况                                                                                                            
2. constant_data 的键结构与时间维度：                                                                                                                                                                    
是否也区分“本期日/同期日/本期月/同期月/供暖期/同供暖期”？若仅日维度，月/供暖期是否按求和或均值？还是按最近有效值？ 
请见对应关系：
value_biz_date：25-26
value_peer_date：24-25
sum_month_biz：25-26
sum_month_peer：24-25
sum_ytd_biz：25-26
sum_ytd_peer：24-25
如果表达式写的是“sum_month_biz”，就代表直接提取视图中对应的item的sum_month_biz值。
如果表达式写的是“A/B”，则表示该位置的值，是同一列（时间口径）的指标A与指标B的除法结果。                                                                 
3. 表达式中的项目名（如“售电量”、“供热量”）是否100%与 item_cn 一致？是否需要容错别名（例如全角/半角/空格差异）？
以“项目字典”反向查询后的英文名作为准确的item进行查询。                                                                                         
4. sum_gongre_branches_detail_data 是否需要额外 sheet_name 过滤？样例里 查询数据源.主键 暂只示例了 company 场景。
我正在取消表sum_gongre_branches_detail_data全部统一到sum_basic_data上，不再有center字段，全部使用company。                                                                     
5.关于“锚点日期”：两张物化视图以刷新时的 current_date - 1 为 biz_date。运行时是否需要允许覆盖基准日（比如手动指定 biz_date），还是完全依赖定时刷新后的视图结果？
这个问题很关键，我本来是没打算去手动指定的，但是，为了未来的灵活性考虑，我增加一对键值，如果为”biz_date”:”regular”，则为默认的“昨日”，如果为例如”2025-10-27”，那就以此作为biz_date。不过我有点疑惑，那就是视图中使用的是固定的biz_date，这个还能改吗？                                        
6.除零与空值策略：当前打算除零返回 None；需要改成 0 或固定字符串（如 "-"）吗？
你说得对，使用"-"                                                                                                                     
7.输出保留小数位与单位格式（例如率类×100显示为百分比）是否在前端处理？还是在后端统一数值标准化再返回？ 
为了减轻前端压力，我希望在后端实现，所有的diff_rate都用百分比显示