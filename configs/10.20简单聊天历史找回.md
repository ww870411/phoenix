好，那么请你修改一下煤炭库存表提交数据后，后端进行的处理流程，与其他表格不同，其指标和结构有其特殊性，但是根据单位/煤种/存储方式等信息，是可以进行拆解重构的，你来为我完成这个过程。我把前端
  提交的数据样式还有我想要你加工成的样子，写在这个文件中了，@D:\编程项目\phoenix\configs\煤炭库存表数据转换.md ，请你参考并考虑如何完成任务，先与我交流，不要改。

✦ 好的，这个任务是使我们之前的“路由分发”设想落地的关键一步。

  我将仔细阅读您提供的 煤炭库存表数据转换.md 文件，以完全理解数据转换的需求，然后与您探讨一个清晰、可行的实现方案。

  ---

  我先来读取您的需求说明文件。
 ╭────────────────────────────────────────────╮
 │ ✓  ReadFile configs\煤炭库存表数据转换.md  │
 ╰────────────────────────────────────────────╯
✦ 好的，我已经仔细学习了您提供的 煤炭库存表数据转换.md 文件。您的需求表述得非常清晰，我完全理解了。

  您提供的“转换前”和“转换后”的示例，精确地定义了我们需要实现的逻辑：将一个“宽”的交叉表数据，拆解（deconstruct）并重构（reshape）成一个“高”的、符合数据库存储规范的记录列表。

  ---

  探讨方案：实现“煤炭库存表专用处理器”

  正如我们之前讨论的，我们将通过“路由分发”模式来解决这个问题。以下是我为您设计的、详细的实现步骤：

  步骤 1: 改造提交流程入口 (submit_data)

  我将把 daily_report_25_26.py 中的 submit_debug 函数重命名为 submit_data，并将其改造为一个“总调度中心”。它会检查传入的 sheet_key：
   * 如果是 Coal_inventory_Sheet，则调用新的、专门的 handle_coal_inventory_submission 函数。
   * 否则，调用现有的、处理标准报表的 handle_daily_basic_submission 函数。

  步骤 2: 实现核心转换函数 (_flatten_records_for_coal)

  这是本次任务的核心。我会创建一个全新的函数，专门负责将前端为煤炭库存表提交的 payload 转换成您期望的格式。它的内部逻辑如下：

   1. 准备字典: 从 payload 中提取 company_dict (单位字典), item_dict (项目字典/煤种字典), 以及 状态字典。为了方便查找，我会将它们的值和键反转，例如从 {"BeiHai": "北海热电厂"} 创建一个
      {"北海热电厂": "BeiHai"} 的反向映射。
   2. 定位数据列: 从 payload 的 columns 数组中，我会定位出哪些列是真正的“数据列”（例如“在途煤炭”, “港口存煤”, “厂内存煤”），并记录下它们的索引位置和列名。
   3. 遍历与拆解:
       * 程序会逐一遍历 payload 中的每一行 row (例如 ["北海热电厂", "烟煤", "吨", "1", "2", "3", ""])。
       * 在每一行内部，程序会再次遍历我们上一步定位到的“数据列”。
       * 对于每一个有值的单元格（例如 "1"），程序都会生成一条独立的、完整的记录。
   4. 构建单条记录:
       * company: 通过反向字典，将行中的“北海热电厂”转换为 "BeiHai"。
       * coal_type: 将“烟煤”转换为 "bituminous_coal"。
       * storage_type: 将数据列的列名“在途煤炭”通过 状态字典 转换为 "coal_in_transit"。
       * value: 填入单元格的值 "1"。
       * date: 使用 payload 中顶层的 biz_date。
       * 其他字段（unit, status 等）也从 payload 的相应位置获取。

  通过这个流程，一个 row 就会根据其数据列的数量，被拆解成多条符合您要求的扁平化记录。

  步骤 3: 实现专用的持久化函数 (_persist_coal_inventory)

  我会创建一个新的数据库写入函数，它：
   1. 使用 CoalInventoryData ORM 模型。
   2. 采用和标准报表完全相同的幂等写入逻辑：在插入新数据前，先根据 biz_date 删除 `coal_inventory_data` 表中所有属于当天业务日期的数据。
   3. 最后，将 _flatten_records_for_coal 生成的所有新记录批量插入数据库。

  ---

  这个方案完整地实现了您在 .md 文件中定义的数据转换逻辑，并且将特殊处理完全封装在独立的函数中，保持了代码的整洁和未来的可扩展性。

  您看这个方案是否清晰可行？如果同意，我将着手开始实施。

> submit_debug这个名字就不变了吧。另外，这个文件@D:\编程项目\phoenix\backend\db\database_daily_report_25_26.py 中的模型我已经改好了，你不需要再改了，除非我改的不对。

✦ 好的，遵从您的指示：

   1. submit_debug 函数名保持不变。
   2. 我将以您修改后的 database_daily_report_25_26.py 文件为准，不再改动它。

  那么，在正式修改后端处理流程之前，我需要先读取一下您修改后的数据库模型文件，以确保我接下来编写的 _persist_coal_inventory 函数能与您定义的 CoalInventoryData
  模型正确匹配。这是一个必要的校验步骤。

  ---
  现在，我来读取 D:\编程项目\phoenix\backend\db\database_daily_report_25_26.py。
 ╭────────────────────────────────────────────────────────╮
 │ ✓  ReadFile ...kend\db\database_daily_report_25_26.py  │
 ╰────────────────────────────────────────────────────────╯
✦ 好的，感谢您提前修改。

  我已经校验了 database_daily_report_25_26.py 文件，发现您定义的 CoalInventoryData 模型与您在 煤炭库存表数据转换.md 中期望生成的数据结构存在一些出入。

  这是个小问题，但非常关键，如果现在不修正，后续的程序在写入数据库时会因为字段不匹配而报错。

  ---

  差异对比

  您期望生成的数据包含以下字段：
  company, company_cn, coal_type, coal_type_cn, `storage_type`, `storage_type_cn`, value, unit, date, `note`, `status`, operation_time

  而您当前在模型中定义的字段为：
  company, company_cn, coal_type, coal_type_cn, value, unit, date, operation_time

  缺失的字段：
  我用黑体标出了，您的模型中缺少了以下几个关键的列定义：
   * storage_type (库存类型, 例如 'coal_in_transit')
   * storage_type_cn (库存类型中文名, 例如 '在途煤炭')
   * note (备注)
   * status (提交状态, 例如 'submit')

  ---

  建议

  为了让程序能正确运行，我们需要先将 CoalInventoryData 模型补充完整。

  我建议将模型修改如下，您看是否可以？

    1 class CoalInventoryData(Base):
    2     __tablename__ = "coal_inventory_data"
    3
    4     id = Column(Integer, primary_key=True)
    5     company = Column(Text, nullable=False)
    6     company_cn = Column(Text)
    7     coal_type = Column(Text, nullable=False)
    8     coal_type_cn = Column(Text)
    9     # 新增下面几列
   10     storage_type = Column(Text, nullable=False)
   11     storage_type_cn = Column(Text)
   12     note = Column(Text)
   13     status = Column(Text)
   14     # 已有列
   15     value = Column(Numeric(18, 4))
   16     unit = Column(Text)
   17     date = Column(Date, nullable=False)
   18     operation_time = Column(DateTime, nullable=False)

  如果同意这个修改，请授权我来更新 database_daily_report_25_26.py 文件。地基打牢后，我再继续为您实现后续的数据处理流程。